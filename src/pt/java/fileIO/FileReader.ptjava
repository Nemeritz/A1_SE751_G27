package fileIO;

import facegallery.utils.CloudVisionFaceDetector;
import pt.runtime.TaskIDGroup;
import facegallery.utils.ByteArray;

import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;
import java.lang.System;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FileReader {

    private List<AtomicBoolean> finishedReadingSequential;
    private List<AtomicBoolean> finishedReadingParallel;

    public List<ByteArray> getImagesFilesSequential(File folder) {
        File[] files = folder.listFiles();
        List<ByteArray> data = new ArrayList<ByteArray>(files.length);
        finishedReadingSequential = new ArrayList<AtomicBoolean>(files.length);
        Path path;

        for (int i = 0; i < files.length; i++) {
            if (files[i].isFile()) {
                try {
                    path = files[i].toPath();
                    data.set(i, new ByteArray(Files.readAllBytes(path)));
                    this.finishedReadingSequential.set(i, new AtomicBoolean(true));
                }
                catch (IOException ie) {
                    this.finishedReadingSequential.set(i, new AtomicBoolean(false));
                    ie.printStackTrace();
                }
            }
        }
        return data;
    }

    public List<AtomicBoolean> getFinishedSequential() {
        return this.finishedReadingSequential;
    }

    public List<AtomicBoolean> getFinishedParallel() {
        return this.finishedReadingParallel;
    }

    IO_TASK private ByteArray readFileWorker(Path path) {
    	try {
            ByteArray newImage = new ByteArray(Files.readAllBytes(path));
            this.finishedReadingParallel.add(new AtomicBoolean(true));
            return newImage;
        } catch (IOException e) {
            e.printStackTrace();
            this.finishedReadingParallel.add(new AtomicBoolean(false));
            return null;
        }
    }

    public List<AtomicBoolean> createParallelDetectionContainer(int fileBytesSize) {
    	List<AtomicBoolean> detections = new ArrayList(fileBytesSize);
    	for (int i = 0; i < fileBytesSize; i++) {
    		detections.add(new AtomicBoolean(true));
    	}
    	return detections;
    }

    TASK public List<ByteArray> getImagesFilesParallel(File folder) {
        Path path;
        List<ByteArray> data = new ArrayList(folder.listFiles().length);
        finishedReadingSequential = new ArrayList<AtomicBoolean>(folder.listFiles().length);
        File[] files = folder.listFiles();
        TaskIDGroup<Void> readIOTasks = new TaskIDGroup(files.length);

        for (int i = 0; i < files.length; i++) {
            if (files[i].isFile()) {
                path = files[i].toPath();
                readIOTasks.add(readFileWorker(path));
            }
        }

        try {
            readIOTasks.waitTillFinished();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return data;
    }
}
